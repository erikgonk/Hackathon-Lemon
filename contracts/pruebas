// Prefijo para la clave de almacenamiento
#define LOYALTY_POINTS_KEY 0x01

// Función para crear la clave de almacenamiento única para cada cliente
void create_storage_key(uint8_t *address, uint8_t *storage_key) {
    memcpy(storage_key, &LOYALTY_POINTS_KEY, 1);  // Usamos el prefijo
    memcpy(storage_key + 1, address, 20);         // Dirección del cliente (20 bytes)
}

ArbResult add_points(uint8_t *input, size_t len) {
    if (len != 64) return (ArbResult){Failure, NULL, 0};  // Verificamos que el tamaño sea 64 bytes

    uint8_t *address = input;      // Primeros 32 bytes: dirección
    uint8_t *points = input + 32;  // Últimos 32 bytes: puntos a sumar

    uint8_t storage_key[32];
    create_storage_key(address, storage_key);

    uint8_t current_points[32] = {0};
    storage_read(storage_key, current_points, 32);  // Leemos los puntos actuales

    // Sumamos los puntos
    bebi32 current = bebi32_from_bytes(current_points);
    bebi32 to_add = bebi32_from_bytes(points);
    bebi32 new_balance = bebi32_add(current, to_add);

    bebi32_to_bytes(new_balance, buf_out);
    storage_write(storage_key, buf_out, 32);  // Guardamos el nuevo saldo

    return _return_success_bebi32(buf_out);
}

ArbResult redeem_points(uint8_t *input, size_t len) {
    if (len != 64) return (ArbResult){Failure, NULL, 0};  // Verificamos que el tamaño sea 64 bytes

    uint8_t *address = input;      // Primeros 32 bytes: dirección
    uint8_t *points = input + 32;  // Últimos 32 bytes: puntos a redimir

    uint8_t storage_key[32];
    create_storage_key(address, storage_key);

    uint8_t current_points[32] = {0};
    storage_read(storage_key, current_points, 32);  // Leemos los puntos actuales

    // Restamos los puntos
    bebi32 current = bebi32_from_bytes(current_points);
    bebi32 to_redeem = bebi32_from_bytes(points);

    // Verificamos que tenga suficientes puntos
    if (bebi32_cmp(current, to_redeem) < 0) {
        return (ArbResult){Failure, NULL, 0};  // Saldo insuficiente
    }

    bebi32 new_balance = bebi32_sub(current, to_redeem);
    bebi32_to_bytes(new_balance, buf_out);
    storage_write(storage_key, buf_out, 32);  // Guardamos el nuevo saldo

    return _return_success_bebi32(buf_out);
}


ArbResult check_points(uint8_t *input, size_t len) {
    if (len != 32) return (ArbResult){Failure, NULL, 0};  // Verificamos que el tamaño sea 32 bytes

    uint8_t *address = input;  // Dirección del cliente (32 bytes)

    uint8_t storage_key[32];
    create_storage_key(address, storage_key);

    uint8_t current_points[32] = {0};
    storage_read(storage_key, current_points, 32);  // Leemos los puntos actuales

    return _return_success_bebi32(current_points);  // Devolvemos los puntos actuales
}

int handler(size_t argc) {
    uint8_t argv[argc];
    read_args(argv);  // Leemos los argumentos

    // Registro de las funciones disponibles
    FunctionRegistry registry[] = {
        {to_function_selector("add_points(bytes32,bytes32)"), add_points},
        {to_function_selector("redeem_points(bytes32,bytes32)"), redeem_points},
        {to_function_selector("check_points(bytes32)"), check_points},
    };

    uint32_t signature = *((uint32_t *)argv);  // Tomamos el selector de función
    ArbResult res = call_function(
        registry, sizeof(registry) / sizeof(registry[0]),
        signature, argv + 4, argc - 4
    );

    return (write_result(res.output, res.output_len), res.status);
}

ENTRYPOINT(handler)
